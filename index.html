
<html>
    <section id="loading-screen">

        <div id="loader"></div>
    
    </section>
<head>
	
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="=ie=edge"
<meta name="description" content="A Website for Art, Music, Media, and Fashion produced by Otis Gordon">
<meta name="keywords" content="Artist, artist, abstract art, Painting, Fashion, spotify artist, the artist, 90s fashion">
<link rel="Shortcut icon" type="image/ico" href="./favicon.ico" />
	
<title>Otis Gordon - a website for the people</title>

<div class="content">
    <nav class="mainnav">
        <ul>
            <a href="contact.html">     home</a></li>
        </ul>
    </nav>

<style>

html, body {
	overflow: hidden;
	margin: 0;
	width: 100%;
	height: 100%;
    background-color:#000000;
}

#loading-screen {
	position: absolute;
	z-index: 2;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: #000000;
	opacity: 1;
 	transition: 1s opacity;
}

#loading-screen.fade-out {
    opacity: 0;
}

#loader {
    display: block;
    position: relative;
    left: 44%;
    top: 40%;
    width: 300px;
    height: 300px;
    margin: -75px 0 0 -75px;
    border-radius: 50%;
    border: 2px solid transparent;
    border-top-color: #c9b3dd;
    -webkit-animation: spin 2s linear infinite;
    animation: spin 2s linear infinite;
}

#loader before {
    content: "";
    position: absolute;
    top: 5px;
    left: 5px;
    right: 5px;
    bottom: 5px;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #BA55D3;
    -webkit-animation: spin 3s linear infinite;
    animation: spin 3s linear infinite;
}

#loader after {
    content: "";
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    bottom: 15px;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #FF00FF;
    -webkit-animation: spin 1.5s linear infinite;
    animation: spin 1.5s linear infinite;
}

@-webkit-keyframes spin {
    0%   {
        -webkit-transform: rotate(0deg);
        -ms-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(360deg);
        -ms-transform: rotate(360deg);
        transform: rotate(360deg);
    }
}

@keyframes spin {
    0%   {
        -webkit-transform: rotate(0deg);
        -ms-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(360deg);
        -ms-transform: rotate(360deg);
        transform: rotate(360deg);
    }
}


</style>

<style>
    .crosshair       { cursor: crosshair; }
    body{margin: 0}
    canvas {width: 100%; height: 100%}
<!-- </style>
<body>
    <script src="static/three.js"></script> 
    <script src="static/OrbitControls.js"></script>
    <script src="static/OBJLoader.js"></script>   
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.1.2/socket.io.min.js" integrity="sha512-fANg+hKlIqBdTzgYBT8eFIlZgKYTLij0S7Afvda/rw/Rm33I9+74HSdR1Urz2zGgCSZiQweMin46+l1obnoLWQ==" crossorigin="anonymous"></script>
    <script src="static/FlyControls.js"></script>   

    <script>
        var scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x0a0101 );
        scene.fog = new THREE.Fog( 0x455382, 2, 100 );
        container = document.createElement( 'div' );
		document.body.appendChild( container )
        var camera = new THREE.PerspectiveCamera (100, window.innerWidth/window.innerHeight, .1, 1000);
        //const camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
        //scene.add( camera );
        var renderer = new THREE.WebGLRenderer ();
        renderer.setSize (window.innerWidth, window.innerHeight); 
        document.body.appendChild(renderer.domElement);
        

        const loadingManager = new THREE.LoadingManager( () => {
	
         const loadingScreen = document.getElementById( 'loading-screen' );
         loadingScreen.classList.add( 'fade-out' );
    
            loadingScreen.addEventListener( 'transitionend', onTransitionEnd );
    
        } );


        window.addEventListener('resize', function(){
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize (width, height);
            camera.aspect =width/height;
            camera.updateProjectionMatrix();


        } );

        controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.rotateSpeed = .5;
			    controls.zoomSpeed = .7;
				controls.panSpeed = 1;
                controls.maxPolarAngle = Math.PI ;
                controls.minDistance = .01;
				controls.maxDistance = 30;

				controls.staticMoving = true;

				controls.minDistance = 0.3;
				controls.maxDistance = 0.3 * 100;
        
                /* controls = new THREE.FlyControls( camera, renderer.domElement );

                controls.movementSpeed = 100;
                controls.domElement = renderer.domElement;
                controls.rollSpeed = Math.PI / 24;
                controls.autoForward = false;
                controls.dragToLook = false; */
        

        //Ground
        // const plane = new THREE.Mesh(
		// 			new THREE.PlaneGeometry( 500, 500 ),
		// 			new THREE.MeshPhongMaterial( { color: 0x1e3d12, specular: 0x101010 } )
		// 		);
		// 		plane.rotation.x = - Math.PI / 2;
		// 		plane.position.y = - 2.5;
		// 		scene.add( plane );

		// 		plane.receiveShadow = true;


        //create shape
            const geometry = new THREE.BoxGeometry( 10, 10, 10 );
            const material = new THREE.MeshBasicMaterial( {color: 0xe80527, wireframe: true} );
            const cube = new THREE.Mesh( geometry, material );
            scene.add(  );
            camera.position.z = 10;

            /* //Texture   
            //const texture = new THREE.TextureLoader().load( "js/262.jpg" ); */

            
            //TEXT

            const loader1 = new THREE.FontLoader();
			loader1.load( 'static/helvetiker_regular.typeface.json', function ( font ) { 
                const color = 0xe1e8f2;

                const matDark = new THREE.LineBasicMaterial( {
                    color: color,
                    side: THREE.DoubleSide
                } );

                const matLite = new THREE.MeshBasicMaterial( {
                    color: color,
                    transparent: true,
                    opacity: .2,
                    side: THREE.DoubleSide
                } );

                const message = "The floor seemed wonderfully solid.";
                const message1 = "                                                               left click: rotate, scroll: zoom, right click: drag "

					const shapes = font.generateShapes( message, 3 );
                    const shapes1 = font.generateShapes( message1, 1/2 );

					const geometry = new THREE.ShapeGeometry( shapes );
                    const geometry1 = new THREE.ShapeGeometry( shapes1 );

					geometry.computeBoundingBox();
                    geometry1.computeBoundingBox();

					const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
                    const xMid1 =  -0.5 * ( geometry1.boundingBox.max.x - geometry1.boundingBox.min.x );

					geometry.translate( xMid, 10, -20 );
                    geometry1.translate( xMid, -8 , -7 );

					// make shape ( N.B. edge view not visible )

					const text = new THREE.Mesh( geometry, matLite );
                    const text1 = new THREE.Mesh( geometry1, matLite );
					text.position.z = - 1;
                    text1.position.z = - 1;
					scene.add( text );
                    //scene.add( text1 );

					// make line shape ( N.B. edge view remains visible )

					const holeShapes = [];

					for ( let i = 0; i < shapes.length; i ++ ) {

						const shape = shapes[ i ];

						if ( shape.holes && shape.holes.length > 0 ) {

							for ( let j = 0; j < shape.holes.length; j ++ ) {

								const hole = shape.holes[ j ];
								holeShapes.push( hole );

							}
                        }
                    }

                    shapes.push.apply( shapes, holeShapes );

                    const lineText = new THREE.Object3D();

                    for ( let i = 0; i < shapes.length; i ++ ) {

                        const shape = shapes[ i ];

                        const points = shape.getPoints();
                        const geometry = new THREE.BufferGeometry().setFromPoints( points );

                        geometry.translate( xMid, 8, -15 );

                        const lineMesh = new THREE.Line( geometry, matDark );
                        lineText.add( lineMesh );

                    }

                    scene.add( lineText );

                    } ); //end load function


       //PLYLOADER
       const loader = new THREE.OBJLoader(loadingManager);

				loader.load( 'static/glen.obj', ( obj ) => {

					//geometry.computeVertexNormals();
                    //add color: color: 0xeb2d36
					const material = new THREE.PointsMaterial( { color: 0xccd2e6, size: .007 } );
					const mesh = new THREE.Points(obj.children[0].geometry, material );

					mesh.position.y = 0;
					mesh.position.z = 15;
                    //mesh.position.z = -2/5;
					//mesh.rotation.x = - Math.PI / 2;
					mesh.scale.multiplyScalar( 1 );

					//mesh.castShadow = true;
					//mesh.receiveShadow = true;

					scene.add( mesh );
        
                });

				/* loader.load( 'static/dense_model.obj', ( obj ) => {

					//geometry.computeVertexNormals();
                    //add color: color: 0xeb2d36
					const material = new THREE.PointsMaterial( { color: 0xa39ff5, size: .015 } );
					const mesh = new THREE.Points(obj.children[0].geometry, material );

					mesh.position.y = 0;
					mesh.position.z = 13;
                    mesh.position.x = -45;
                    //mesh.position.z = -2/5;
					//mesh.rotation.x = - Math.PI / 2;
					mesh.scale.multiplyScalar( .5 );

					//mesh.castShadow = true;
					//mesh.receiveShadow = true;

					scene.add( mesh );
        
                }); */

                //LIGHTS


// Lights

            scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

            addShadowedLight( 1, 1, 1, 0xedf4ff, 1.35 );
            addShadowedLight( 0.5, 1, - 1, 0xedf4ff, 1 );

            // renderer

            // renderer = new THREE.WebGLRenderer( { antialias: true } );
            // renderer.setPixelRatio( window.devicePixelRatio );
            // renderer.setSize( window.innerWidth, window.innerHeight );
            // renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.shadowMap.enabled = true;

            //container.appendChild( renderer.domElement );

        

            // resize

            //window.addEventListener( 'resize', onWindowResize );

            

            function addShadowedLight( x, y, z, color, intensity ) {

            const directionalLight = new THREE.DirectionalLight( color, intensity );
            directionalLight.position.set( x, y, z );
            scene.add( directionalLight );

            directionalLight.castShadow = true;

            const d = 1;
            directionalLight.shadow.camera.left = - d;
            directionalLight.shadow.camera.right = d;
            directionalLight.shadow.camera.top = d;
            directionalLight.shadow.camera.bottom = - d;

            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 4;

            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;

            directionalLight.shadow.bias = - 0.001;

            }

             function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            controls.handleResize();
                 }

            
            function onTransitionEnd(event) {

                event.target.remove();

            }

        //update

        var update = function (){
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.02;
        }
        var render = function (){
            renderer.render( scene, camera);
            const timer = Date.now() * 0.0005;

				//camera.position.x = -Math.sin( timer ) * 10;
                //camera.rotation.y = -Math.sin(timer) * .2;
                //camera.position.y = -Math.sin( timer ) * 1;
				//camera.position.z = -Math.cos( timer ) * 2;

				//camera.lookAt( cameraTarget );

				//renderer.render( scene, camera );
        };




        var GameLoop = function (){
           requestAnimationFrame( GameLoop );
           update( );
           render( );

        };
        GameLoop( );

    </script>

</body>

</head>
</html> 
