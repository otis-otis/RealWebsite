<!DOCTYPE html>
<html>
  <section id="loading-screen">

      <div id="loader"></div>
  
  </section>

<head>
  
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="=ie=edge"
<meta name="keywords" content="HTML, CSS, JavaScript">


<style>
html, body {
overflow: hidden;
margin: 0;
width: 100%;
height: 100%;
  background-color:#000000;
}

#loading-screen {
position: absolute;
z-index: 2;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: #dddcb4;
opacity: 1;
 transition: 1s opacity;
}

#loading-screen.fade-out {
  opacity: 0;
}

#loader {
  display: block;
  position: relative;
  left: 44%;
  top: 40%;
  width: 300px;
  height: 300px;
  margin: -75px 0 0 -75px;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: #c9b3dd;
  -webkit-animation: spin 2s linear infinite;
  animation: spin 2s linear infinite;
}

#loader before {
  content: "";
  position: absolute;
  top: 5px;
  left: 5px;
  right: 5px;
  bottom: 5px;
  border-radius: 50%;
  border: 3px solid transparent;
  border-top-color: #BA55D3;
  -webkit-animation: spin 3s linear infinite;
  animation: spin 3s linear infinite;
}

#loader after {
  content: "";
  position: absolute;
  top: 15px;
  left: 15px;
  right: 15px;
  bottom: 15px;
  border-radius: 50%;
  border: 3px solid transparent;
  border-top-color: #FF00FF;
  -webkit-animation: spin 1.5s linear infinite;
  animation: spin 1.5s linear infinite;
}

@-webkit-keyframes spin {
  0%   {
      -webkit-transform: rotate(0deg);
      -ms-transform: rotate(0deg);
      transform: rotate(0deg);
  }
  100% {
      -webkit-transform: rotate(360deg);
      -ms-transform: rotate(360deg);
      transform: rotate(360deg);
  }
}

@keyframes spin {
  0%   {
      -webkit-transform: rotate(0deg);
      -ms-transform: rotate(0deg);
      transform: rotate(0deg);
  }
  100% {
      -webkit-transform: rotate(360deg);
      -ms-transform: rotate(360deg);
      transform: rotate(360deg);
  }
}

@import url('https://fonts.googleapis.com/css2?family=Bungee+Shade&family=Spectral&display=swap');* { box-sizing: border-box;}


/*
 * Made by Erik Terwan
 * 24th of November 2015
 * MIT License
 *
 *
 * If you are thinking of using this in
 * production code, beware of the browser
 * prefixes.
 */

      body
      {
        position: relative;
        margin: 0;
        padding: 0;
        /* make it look decent enough */
        color: #daacac;
      }
      
      #menuToggle
      {
        display: block;
        position: fixed;
        top: 50px;
        left: 50px;
        
        z-index: 1;
        
        -webkit-user-select: none;
        user-select: none;
      }
      
      #menuToggle a
      {
        text-decoration: none;
        color: #232323;
        
        transition: color 0.3s ease;
      }
      
      #menuToggle a:hover
      {
        color: rgb(23, 143, 19);
      }
      
      
      #menuToggle input
      {
        display: block;
        width: 40px;
        height: 32px;
        position: absolute;
        top: -7px;
        left: -5px;
        
        cursor: pointer;
        
        opacity: 0; /* hide this */
        z-index: 2; /* and place it over the hamburger */
        
        -webkit-touch-callout: none;
      }
      
      /*
        * Just a quick hamburger
        */
      #menuToggle span
      {
        display: block;
        width: 33px;
        height: 4px;
        margin-bottom: 5px;
        position: relative;
        
        background: #9FC2BA;
        border-radius: 3px;
        
        z-index: 1;
        
        transform-origin: 4px 0px;
        
        transition: transform 0.5s cubic-bezier(0.77,0.2,0.05,1.0),
                    background 0.5s cubic-bezier(0.77,0.2,0.05,1.0),
                    opacity 0.55s ease;
      }
      
      #menuToggle span:first-child
      {
        transform-origin: 0% 0%;
      }
      
      #menuToggle span:nth-last-child(2)
      {
        transform-origin: 0% 100%;
      }
      
      /* 
        * Transform all the slices of hamburger
        * into a crossmark.
        */
      #menuToggle input:checked ~ span
      {
        opacity: 1;
        transform: rotate(45deg) translate(-2px, -1px);
        background: #232323;
      }
      
      /*
        * But let's hide the middle one.
        */
      #menuToggle input:checked ~ span:nth-last-child(3)
      {
        opacity: 0;
        transform: rotate(0deg) scale(0.2, 0.2);
      }
      
      /*
        * Ohyeah and the last one should go the other direction
        */
      #menuToggle input:checked ~ span:nth-last-child(2)
      {
        transform: rotate(-45deg) translate(0, -1px);
      }
      
      /*
        * Make this absolute positioned
        * at the top left of the screen
        */
      #menu
      {
        position: absolute;
        width: 300px;
        margin: -100px 0 0 -50px;
        padding: 50px;
        padding-top: 125px;
        
        background: #ffffff;
        list-style-type: none;
        -webkit-font-smoothing: antialiased;
        /* to stop flickering of text in safari */
        
        transform-origin: 0% 0%;
        transform: translate(-100%, 0);
        
        transition: transform 0.5s cubic-bezier(0.77,0.2,0.05,1.0);
      }
      

      #menu li
      {
        padding: 10px 0;
        font-size: 30px;
      }
      
      /*
        * And let's slide it in from the left
        */
      #menuToggle input:checked ~ ul
      {
        transform: none;
      }

      .art{
        right: 50px;
        max-width: 70%;
        margin: auto 40px;
        object-fit:contain}

        .music{
          right: 50px;
          max-width: 70%;
          margin: auto 40px;

          object-fit:contain}

          .other{
            right: 50px;
            max-width: 70%;
            margin: auto 40px;

            object-fit:contain}

            .contact{
              right: 50px;
              max-width: 70%;
              margin: auto 40px;
              object-fit:contain}


      /* DONE WITH HAMBURGER */

</style>


<body>
  <script src="static/three.js"></script> 
  <script src="static/OrbitControls.js"></script>
  <script src="static/OBJLoader.js"></script>
  

  <script>
      var scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xf6f7f2 );
      scene.fog = new THREE.Fog( 0x455382, 2, 50 );
      container = document.createElement( 'div' );
      document.body.appendChild( container )
      var camera = new THREE.PerspectiveCamera (100, window.innerWidth/window.innerHeight, .1, 1000);
      //const camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
      //scene.add( camera );
      var renderer = new THREE.WebGLRenderer ();
      renderer.setSize (window.innerWidth, window.innerHeight); 
      camera.position.set(0,-1,27);
      document.body.appendChild(renderer.domElement);
      

      const loadingManager = new THREE.LoadingManager( () => {

      const loadingScreen = document.getElementById( 'loading-screen' );
      loadingScreen.classList.add( 'fade-out' );
  
       loadingScreen.addEventListener( 'transitionend', onTransitionEnd );
  
      } );


      window.addEventListener('resize', function(){
          var width = window.innerWidth;
          var height = window.innerHeight;
          renderer.setSize (width, height);
          camera.aspect =width/height;
          camera.updateProjectionMatrix();


      } );

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.rotateSpeed = .5;
      controls.zoomSpeed = .7;
      controls.panSpeed = 1;
      controls.maxPolarAngle = Math.PI ;
      controls.minDistance = .01;
      controls.maxDistance = 30;

      controls.staticMoving = true;

      controls.minDistance = 0.3;
      controls.maxDistance = 0.3 * 100;
      
              /* controls = new THREE.FlyControls( camera, renderer.domElement );

              controls.movementSpeed = 100;
              controls.domElement = renderer.domElement;
              controls.rollSpeed = Math.PI / 24;
              controls.autoForward = false;
              controls.dragToLook = false; */
      

            
            const plane = new THREE.Mesh(
              new THREE.PlaneGeometry( 500, 500 ),
              new THREE.MeshPhongMaterial( { color: 0xf6f7f2, specular: 0x101010 } )
            );
            plane.rotation.x = - Math.PI / 2;
            plane.position.y = - 2.5;
            scene.add();

            plane.receiveShadow = true;


      //create shape
          const geometry = new THREE.BoxGeometry( 10, 10, 10 );
          const material = new THREE.MeshBasicMaterial( {color: 0xe80527, wireframe: true} );
          const cube = new THREE.Mesh( geometry, material );
          scene.add();
          // camera.position.z = 100;
          // camera.position.y = -100;
 
           
          //const texture = new THREE.TextureLoader().load( "js/262.jpg" );

          
          //TEXT

          const loader1 = new THREE.FontLoader();
          loader1.load('Static/helvetiker_regular.typeface.json', function ( font ) { 
              const color = 0x151515;

              const matDark = new THREE.LineBasicMaterial( {
                  color: color,
                  side: THREE.DoubleSide
              } );

              const matLite = new THREE.MeshBasicMaterial( {
                  color: 0x9FC2BA,
                  transparent: true,
                  opacity: 1,
                  side: THREE.DoubleSide
              } );

              const message = "Welcome to Otis Gordon's Website";
              const message1 = "                       hello";


        const shapes = font.generateShapes( message, 3 );
                  const shapes1 = font.generateShapes( message1, 1 );

        const geometry = new THREE.ShapeGeometry( shapes );
                  const geometry1 = new THREE.ShapeGeometry( shapes1 );

        geometry.computeBoundingBox();
                  geometry1.computeBoundingBox();

        const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
                  const xMid1 =  -0.5 * ( geometry1.boundingBox.max.x - geometry1.boundingBox.min.x );

        geometry.translate( xMid, 10, -20 );
        geometry1.translate( -10, 1 , -30 );

        // make shape ( N.B. edge view not visible )

        const text = new THREE.Mesh( geometry, matLite );
                  const text1 = new THREE.Mesh( geometry1, matLite );
        text.position.z = - 1;
                  text1.position.z = 40;
        scene.add(  );
                  scene.add( text1 );

        // make line shape ( N.B. edge view remains visible )

        const holeShapes = [];

        for ( let i = 0; i < shapes.length; i ++ ) {

          const shape = shapes[ i ];

          if ( shape.holes && shape.holes.length > 0 ) {

            for ( let j = 0; j < shape.holes.length; j ++ ) {

              const hole = shape.holes[ j ];
              holeShapes.push( hole );

            }
                      }
                  }

                  shapes.push.apply( shapes, holeShapes );

                  const lineText = new THREE.Object3D();

                  for ( let i = 0; i < shapes.length; i ++ ) {

                      const shape = shapes[ i ];

                      const points = shape.getPoints();
                      const geometry = new THREE.BufferGeometry().setFromPoints( points );

                      geometry.translate( xMid, 8, -15 );

                      const lineMesh = new THREE.Line( geometry, matDark );
                      lineText.add( lineMesh );

                  }

                  scene.add( lineText );

                  } ); //end load function


     //PLYLOADER
     const loader = new THREE.OBJLoader(loadingManager);

      loader.load( 'Static/Hand.obj', ( obj ) => {

        geometry.computeVertexNormals();
        //add color: 0xeb2d36;
        const material = new THREE.PointsMaterial( { color: 0xccd2e6, size: .1 } );
        const mesh = new THREE.Points(obj.children[0].geometry, material );

        mesh.position.y = -22;
        mesh.position.z = -2;
        mesh.position.x = 18;
        //mesh.position.z = -2/5;
        mesh.rotateSpeed = .1;
        mesh.rotation.x = - Math.PI / 6 ;
        mesh.rotation.y= - Math.PI / 2;
        mesh.scale.multiplyScalar( .1);

        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        scene.add( mesh );
      
              });

      /* loader.load( 'static/dense_model.obj', ( obj ) => {

        //geometry.computeVertexNormals();
                  //add color: color: 0xeb2d36
        const material = new THREE.PointsMaterial( { color: 0xa39ff5, size: .015 } );
        const mesh = new THREE.Points(obj.children[0].geometry, material );

        mesh.position.y = 0;
        mesh.position.z = 13;
                  mesh.position.x = -45;
                  //mesh.position.z = -2/5;
        //mesh.rotation.x = - Math.PI / 2;
        mesh.scale.multiplyScalar( .5 );

        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        scene.add( mesh );
      
              }); */

              //LIGHTS


// Lights

          scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

          addShadowedLight( 1, 1, 1, 0xedf4ff, 1.35 );
          addShadowedLight( 0.5, 1, - 1, 0xedf4ff, 1 );

          // renderer

          // renderer = new THREE.WebGLRenderer( { antialias: true } );
          // renderer.setPixelRatio( window.devicePixelRatio );
          // renderer.setSize( window.innerWidth, window.innerHeight );
          // renderer.outputEncoding = THREE.sRGBEncoding;

          renderer.shadowMap.enabled = true;

          //container.appendChild( renderer.domElement );

      

          // resize

          //window.addEventListener( 'resize', onWindowResize );

          

          function addShadowedLight( x, y, z, color, intensity ) {

          const directionalLight = new THREE.DirectionalLight( color, intensity );
          directionalLight.position.set( x, y, z );
          scene.add( directionalLight );

          directionalLight.castShadow = true;

          const d = 1;
          directionalLight.shadow.camera.left = - d;
          directionalLight.shadow.camera.right = d;
          directionalLight.shadow.camera.top = d;
          directionalLight.shadow.camera.bottom = - d;

          directionalLight.shadow.camera.near = 1;
          directionalLight.shadow.camera.far = 4;

          directionalLight.shadow.mapSize.width = 1024;
          directionalLight.shadow.mapSize.height = 1024;

          directionalLight.shadow.bias = - 0.001;

          }

           function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
           camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
          controls.handleResize();
               }

          
          function onTransitionEnd(event) {

              event.target.remove();

          }

      //update

      var update = function (){
          cube.rotation.x += 0.01;
          cube.rotation.y += 0.02;
      }
      var render = function (){
          renderer.render( scene, camera);
          const timer = Date.now() * 0.0005;

      //camera.position.x = -Math.sin( timer ) * 10;
              //camera.rotation.y = -Math.sin(timer) * .2;
              //camera.position.y = -Math.sin( timer ) * 1;
      //camera.position.z = -Math.cos( timer ) * 2;

      //camera.lookAt( cameraTarget );

      //renderer.render( scene, camera );
      };




      var GameLoop = function (){
        requestAnimationFrame( GameLoop );
         update( );
         render( );

      };
      GameLoop( );

  </script>

</body>

</head>
</html> 
